from json import dumpsfrom os import makedirs, listdir, removefrom shutil import rmtreefrom sqlite3 import IntegrityError, OperationalErrorfrom emoji import is_emojifrom telegram.error import Forbidden, BadRequestfrom backend import *from bs4 import BeautifulSoupfrom os.path import existsfrom constants import *from contextlib import suppressfrom hammett_extensions.carousel import BaseCarouselWidgetfrom hammett.core.exceptions import ScreenDescriptionIsEmptyfrom hammett.core import Screen, Buttonfrom hammett.core.constants import SourceTypes, RenderConfigfrom hammett.core.handlers import register_button_handler, register_typing_handlerfrom hammett.core.hider import ONLY_FOR_ADMIN, Hiderfrom hammett.core.mixins import StartMixinfrom hammett_extensions.handlers import register_input_handlerfrom hammett.conf import settingsasync def send_update_notification(update, _context, status, index, is_order: bool):    user = update.effective_user    name = get_username(user.first_name, user.last_name, user.username)    await logger_alert([name, user.id], status, index, is_order, _context)    task_description = await get_var_from_database(index, "task_description", is_order, _context)    task_day = await get_var_from_database(index, "task_day", is_order, _context)    task_month = await get_var_from_database(index, "task_month", is_order, _context)    task_month_int = int(task_month)    task_month = recognise_month(task_month)    task_year = await get_var_from_database(index, "task_year", is_order, _context)    user_id_list = []    for id_row in cursor.execute(            'SELECT id FROM Users WHERE send_notification = 1 AND id IN (SELECT user_id FROM UserCommunities WHERE class_name = %s)',            (_context.user_data['CURRENT_CLASS_NAME'],)):        id_row = list(id_row)        id_row = int(id_row[0])        user_id_list.append(id_row)    for user_id in user_id_list:        cursor.execute("SELECT name FROM Users WHERE id = %s", (user_id,))        user_name = cursor.fetchall()        user_name = get_clean_var(user_name, "to_string", 0, True)        notification_title = "<strong>Здравствуйте, " + str(user_name) + "!" + "\n"        notification_title += await get_notification_title(_context, task_description, task_day, task_month_int,                                                           task_month,                                                           task_year, status)        new_config = RenderConfig(            chat_id=user_id        )        try:            if len(_context.user_data['MEDIA_ADD']) > 1:                new_notification = CarouselNotificationScreen()            else:                new_notification = StaticNotificationScreen()                new_notification.images = []            if exists(str(settings.MEDIA_ROOT) + '/' + str(index) + '/'):                add_images = listdir(str(settings.MEDIA_ROOT) + '/' + str(index) + "/")                for image in add_images:                    path = str(index) + "/" + str(image)                    item = [settings.MEDIA_ROOT / path, notification_title]                    new_notification.images.append(item)                if len(_context.user_data['MEDIA_ADD']) == 1:                    new_notification.description = notification_title                    new_notification.current_images = new_notification.images[0]                    new_notification.cover = new_notification.current_images[0]            else:                new_notification.images = [                    [settings.MEDIA_ROOT / 'logo.webp', notification_title]                ]        except KeyError:            new_notification = StaticNotificationScreen()            new_notification.description = notification_title            new_notification.images = [                [settings.MEDIA_ROOT / 'logo.webp', ""]            ]        new_config.keyboard = [            [                Button(BUTTON_BACK_TO_MENU, MainMenu,                       source_type=SourceTypes.JUMP_SOURCE_TYPE)            ]        ]        try:            await new_notification.send(_context, config=new_config, extra_data=None)        except Forbidden:            cursor.execute('DELETE FROM UserCommunities WHERE user_id = %s', (user_id,))            cursor.execute('DELETE FROM Users WHERE id = %s', (user_id,))            connection.commit()        except BadRequest:            for x in range(0, len(notification_title), settings.MAX_CAPTION_LENGTH):                current_description = notification_title[x:x + settings.MAX_CAPTION_LENGTH]                save_markers = save_html_markers(current_description)                soup = BeautifulSoup(save_markers, "html.parser")                soup.prettify()                current_description = str(soup)                current_description = load_html_markers(current_description)                current_description = "<strong>" + current_description + '</strong>'                if x + settings.MAX_CAPTION_LENGTH >= len(notification_title):                    new_config.description = current_description                    return await new_notification.send(_context, config=new_config)                else:                    await update.effective_chat.send_message(current_description, parse_mode='HTML')        with suppress(KeyError):            _context.user_data["MEDIA_ADD"].clear()        if status == 'change':            return await show_notification_screen(update, _context, 'send',                                                  "✅<strong>Задание успешно изменено!</strong>", [                                                      [Button('⬅️ В меню редактора', SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                      [Button("⬅ Изменить ещё задания", SchoolTaskChangeMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                      [Button('⬅️ На главный экран', MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)]])async def add_task_school(update, _context, task_item, task_description, group_number, task_day, task_month,                          task_year):    cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE item_index = %s',                   (_context.user_data['ADDING_TASK_INDEX'],))    db_length = cursor.fetchall()    db_length = get_clean_var(db_length, 'to_int', 0, True)    if db_length > 0:        hypertime = get_hypertime(int(task_month), int(task_day), int(task_year))        cursor.execute(            'INSERT INTO ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks (item_name, item_index, group_number, '                                                                        'task_description, task_day, task_month,'                                                                        'task_year, hypertime)'                                                                        'VALUES'                                                                        '(%s,%s,%s,%s,%s,%s,%s,%s)',            (task_item, _context.user_data["ADD_TASK_ITEM_INDEX"], group_number, task_description, task_day,             task_month, task_year, hypertime,))        connection.commit()        with suppress(KeyError):            if _context.user_data["MEDIA_ADD"]:                makedirs("media/" + _context.user_data["ADD_TASK_ITEM_INDEX"])                for file in _context.user_data["MEDIA_ADD"]:                    filename = _context.user_data["ADD_TASK_ITEM_INDEX"] + "/" + str(generate_id())                    title = "media/"                    original = title + filename                    await file.download_to_drive(original + '.jpeg')                    await convert_to_webp(original + '.jpeg', original + '.webp')                    remove(original + '.jpeg')        _context.user_data["IS_IN_MEDIA_SCREEN"] = False        await send_update_notification(update, _context, "add", _context.user_data["ADD_TASK_ITEM_INDEX"],                                       False)        return await show_notification_screen(update, _context, 'send', "✅<strong>Задание успешно добавлено!</strong>",                                              [                                                  [Button('⬅️ В меню редактора', SchoolTaskManagementMain,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE),                                                   ],                                                  [Button('⬅️ Добавить ещё задание', SchoolTaskAddition,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                  [Button('⬅️ На главный экран', MainMenu,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)]])    else:        return await show_notification_screen(update, _context, 'render',                                              '<strong>Перед добавлением данного задания предмет был удалён!</strong>',                                              [                                                  [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                   ]])class BaseScreen(Screen):    cache_covers = True    hide_keyboard = True    cover = str(settings.MEDIA_ROOT) + '/' + 'logo.webp'class NewsNotificationScreen(BaseScreen):    passclass ScreenNotification(BaseScreen):    passasync def show_notification_screen(update, _context, translation_type: str, description, keyboard):    new_config = RenderConfig()    new_config.description = description    new_config.keyboard = keyboard    if translation_type == 'send':        return await ScreenNotification().send(_context, config=new_config)    elif translation_type == 'render':        return await ScreenNotification().render(update, _context, config=new_config)class MainMenu(StartMixin, BaseScreen):    async def get_config(self, update, _context, **_kwargs):        user_id = update.effective_user.id        config = RenderConfig()        user_name = get_username(update.effective_user.first_name, update.effective_user.last_name,                                 update.effective_user.username)        try:            cursor.execute(                'INSERT INTO Users (send_notification, id, name) '                'VALUES'                '(%s,%s,%s)',                (1, str(user_id), user_name))            connection.commit()            config.description = FIRST_GREET[randint(0, 2)]        except IntegrityError or AttributeError or InFailedSqlTransaction:            connection.rollback()            cursor.execute("UPDATE Users SET name = %s WHERE id = %s", (user_name, user_id,))            connection.commit()            config.description = get_greet(user_name)        config.keyboard = []        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            config.keyboard.append([Button('Зайти в задачник 📓', self.check_class_name_watch,                                           source_type=SourceTypes.HANDLER_SOURCE_TYPE), ])        cursor.execute(            "SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ('ADMIN', 'HOST')",            (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            config.keyboard.append([                Button('Внести изменения в задачник🔧', self.check_class_name_tasks,                       hiders=Hider(ONLY_FOR_ADMIN),                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)])        cursor.execute("SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class = 'HOST'",                       (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            config.keyboard.append([                Button('Внести изменения в сообщество 👥', self.check_class_name_manage,                       hiders=Hider(ONLY_FOR_ADMIN),                       source_type=SourceTypes.HANDLER_SOURCE_TYPE),            ])        config.keyboard.append([Button('Сообщества 👥', CommunitiesMain,                                       source_type=SourceTypes.MOVE_SOURCE_TYPE)])        config.keyboard.append([Button('Настройки ⚙', Options,                                       source_type=SourceTypes.MOVE_SOURCE_TYPE)])        config.keyboard.append([Button('Что нового сегодня? ✨', WhatsNew,                                       source_type=SourceTypes.MOVE_SOURCE_TYPE)])        config.keyboard.append([Button('Подробнее о School Tasker 📋', SocialMedia,                                       source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return config    @register_button_handler    async def check_class_name_watch(self, update, _context):        cursor.execute("SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s", (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length == 1:            cursor.execute('SELECT class_name FROM UserCommunities WHERE user_id = %s',                           (update.effective_user.id,))            _context.user_data['CURRENT_CLASS_NAME'] = cursor.fetchall()            _context.user_data['CURRENT_CLASS_NAME'] = \                get_clean_var(_context.user_data['CURRENT_CLASS_NAME'], 'to_string', 0, True)            st_screen = SchoolTasks()            st_screen.back_button.caption = BUTTON_BACK_TO_MENU            st_screen.back_button.source = MainMenu            await st_screen.check_tasks(update, _context, SchoolTasks)        elif db_length > 1:            return await CommunitySelectionToWatch().move(update, _context)    @register_button_handler    async def check_class_name_tasks(self, update, _context):        cursor.execute(            "SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ('ADMIN', 'HOST')",            (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length == 1:            cursor.execute(                "SELECT class_name FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ('ADMIN', 'HOST')",                (update.effective_user.id,))            _context.user_data['CURRENT_CLASS_NAME'] = cursor.fetchall()            _context.user_data['CURRENT_CLASS_NAME'] = \                get_clean_var(_context.user_data['CURRENT_CLASS_NAME'], 'to_string', 0, True)            return await SchoolTaskManagementMain().move(update, _context)        elif db_length > 1:            return await CommunitySelectionToTasks().move(update, _context)    @register_button_handler    async def check_class_name_manage(self, update, _context):        cursor.execute("SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class = 'HOST'",                       (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length == 1:            cursor.execute(                "SELECT class_name FROM UserCommunities WHERE user_id = %s AND user_role_in_class  = 'HOST'",                (update.effective_user.id,))            _context.user_data['CURRENT_CLASS_NAME'] = cursor.fetchall()            _context.user_data['CURRENT_CLASS_NAME'] = \                get_clean_var(_context.user_data['CURRENT_CLASS_NAME'], 'to_string', 0, True)            return await CommunityManagementMain().move(update, _context)        elif db_length > 1:            return await CommunitySelectionToManage().move(update, _context)    @register_button_handler    async def school_tasks(self, update, _context):        await SchoolTasks().check_tasks(update, _context, SchoolTasks)    async def start(self, update, _context):        """Replies to the /start command. """        try:            user = update.message.from_user        except AttributeError:            # When the start handler is invoked through editing            # the message with the /start command.            user = update.edited_message.from_user        user_name = get_username(user.first_name, user.last_name, user.username)        LOGGER.info('The user %s (%s) was entered to School Tasker', user_name, user.id)        return await super().start(update, _context)class CurrentCommunityChange(BaseScreen):    description = '<strong>Выберите доступное Вам сообщество: </strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT class_name FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        name_list = cursor.fetchall()        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        for i in range(db_length):            new_name = get_clean_var(name_list, 'to_string', i - 1, True)            new_community = [Button(new_name, self.change_class,                                    source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                    payload=dumps({"CURRENT_CLASS_NAME": new_name}))]            keyboard.append(new_community)        keyboard.append([Button(BUTTON_BACK_TO_MENU, MainMenu,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def change_class(self, update, _context):        await get_payload_safe(self, update, _context, "CHANGE_CURRENT_CLASS_NAME", 'CURRENT_CLASS_NAME')        return await MainMenu().move(update, _context)class CommunitySelectionToWatch(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>Выберите одно из предоставленных сообществ: </strong>'        else:            return ('<strong>На данный момент Вы не состоите в каком-нибудь сообществе, чтобы посмотреть домашнее'                    ' задание</strong>')    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT class_name FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        class_name_list = cursor.fetchall()        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s', (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            for i in range(db_length):                new_name = get_clean_var(class_name_list, 'to_string', i - 1, True)                new_button = [Button(new_name, self.press_button,                                     source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                     payload=dumps({"CURRENT_CLASS_NAME": new_name}))]                keyboard.append(new_button)        keyboard.append([Button(BUTTON_BACK_TO_MENU, MainMenu,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def press_button(self, update, _context):        await get_payload_safe(self, update, _context, 'SHOW_TASKS_FOR_CURRENT_CLASS_NAME', 'CURRENT_CLASS_NAME')        st_screen = SchoolTasks()        st_screen.back_button.caption = BUTTON_BACK        st_screen.back_button.source = CommunitySelectionToWatch        await st_screen.check_tasks(update, _context, SchoolTasks)class CommunitySelectionToTasks(BaseScreen):    async def get_description(self, update, _context):        cursor.execute(            "SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ('ADMIN', 'HOST')",            (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>Выберите одно из предоставленных сообществ: </strong>'        else:            return ('<strong>На данный момент Вы не состоите в каком-нибудь сообществе, чтобы посмотреть домашнее'                    ' задание</strong>')    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute(            'SELECT class_name FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ("ADMIN", "HOST")',            (update.effective_user.id,))        class_name_list = cursor.fetchall()        cursor.execute(            'SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class IN ("ADMIN", "HOST")',            (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            for i in range(db_length):                new_name = get_clean_var(class_name_list, 'to_string', i - 1, True)                new_button = [Button(new_name, self.press_button,                                     source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                     payload=dumps({"CURRENT_CLASS_NAME": new_name}))]                keyboard.append(new_button)        keyboard.append([Button(BUTTON_BACK_TO_MENU, MainMenu,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def press_button(self, update, _context):        await get_payload_safe(self, update, _context, 'MANAGE_TASKS_FOR_CURRENT_CLASS_NAME', 'CURRENT_CLASS_NAME')        return await SchoolTaskManagementMain().move(update, _context)class CommunitySelectionToManage(BaseScreen):    async def get_description(self, update, _context):        cursor.execute("SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class = 'HOST'",                       (update.effective_user.id,))        db_length = cursor.fetchone()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>Выберите одно из предоставленных сообществ: </strong>'        else:            return ('<strong>На данный момент Вы не состоите в каком-нибудь сообществе, чтобы посмотреть домашнее'                    ' задание</strong>')    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute("SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s AND user_role_in_class = 'HOST'",                       (update.effective_user.id,))        db_length = cursor.fetchall()        cursor.execute("SELECT class_name FROM UserCommunities WHERE user_id = %s AND user_role_in_class = 'HOST'",                       (update.effective_user.id,))        name_list = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            for i in range(db_length):                new_name = get_clean_var(name_list, 'to_string', i - 1, True)                new_button = [Button(new_name, self.press_button,                                     source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                     payload=dumps({"CURRENT_CLASS_NAME": new_name}))]                keyboard.append(new_button)        keyboard.append([Button(BUTTON_BACK_TO_MENU, MainMenu,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def press_button(self, update, _context):        await get_payload_safe(self, update, _context, 'MANAGE_CLASS_FOR_CURRENT_CLASS_NAME', 'CURRENT_CLASS_NAME')        return await CommunityManagementMain().move(update, _context)class CommunityManagementMain(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT password FROM Community WHERE name = %s', (_context.user_data['CURRENT_CLASS_NAME'],))        _context.user_data['CURRENT_CLASS_PASSWORD'] = cursor.fetchall()        _context.user_data['CURRENT_CLASS_PASSWORD'] = \            get_clean_var(_context.user_data['CURRENT_CLASS_PASSWORD'], 'to_string', 0, True)        return '<strong>Название сообщества: ' + _context.user_data['CURRENT_CLASS_NAME'] + (                '\nПароль: ' + _context.user_data['CURRENT_CLASS_PASSWORD'] + '</strong>')    async def add_default_keyboard(self, update, _context):        keyboard = [            [                Button('Изменить название сообщества', self.change_community_name,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Изменить пароль', self.change_community_password,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]]        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE class_name = %s',                       (_context.user_data['CURRENT_CLASS_NAME'],))        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 1:            keyboard.append([                Button('Изменить права пользователей сообщества', CommunityUserChange,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ])        keyboard.append([            Button('Добавить/удалить предметы', CommunityItemManagement,                   source_type=SourceTypes.MOVE_SOURCE_TYPE)])        keyboard.append([            Button(BUTTON_BACK, self.go_back,                   source_type=SourceTypes.HANDLER_SOURCE_TYPE)        ])        return keyboard    @register_button_handler    async def change_community_name(self, update, _context):        _context.user_dta['CURRENT_TYPING_ACTION'] = 'CHANGING_CLASS_NAME'        return await CommunityNameChange().move(update, _context)    @register_button_handler    async def change_community_password(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_CLASS_PASSWORD'        return await CommunityPasswordChange().move(update, _context)    @register_button_handler    async def go_back(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE user_id = %s and user_role_in_class = "HOST"',                       (update.effective_user.id,))        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 1:            return await CommunitySelectionToManage().move(update, _context)        else:            return await MainMenu().move(update, _context)class CommunityNameChange(BaseScreen):    description = '<strong>Введите новое название для сообщества</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await CommunityManagementMain().move(update, _context)class CommunityPasswordChange(BaseScreen):    description = '<strong>Введите новый пароль для сообщества: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await CommunityManagementMain().move(update, _context)class CommunityUserChange(BaseScreen):    description = '<strong>Выберите пользователя:</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE class_name = %s AND user_id != %s',                       (_context.user_data['CURRENT_CLASS_NAME'], update.effective_user.id,))        list_length = cursor.fetchall()        list_length = get_clean_var(list_length, 'to_int', 0, True)        cursor.execute('SELECT user_id FROM UserCommunities WHERE class_name = %s AND user_id != %s',                       (_context.user_data['CURRENT_CLASS_NAME'], update.effective_user.id,))        id_list = cursor.fetchall()        for new_id in range(list_length):            user_id = get_clean_var(id_list, 'to_string', new_id, True)            cursor.execute('SELECT name FROM Users WHERE id = %s', (user_id,))            user_name = cursor.fetchall()            user_name = get_clean_var(user_name, 'to_string', 0, True)            keyboard.append([Button(user_name, self.checkout_user,                                    source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                    payload=dumps({'CHANGE_USER_ROLE_ID': user_id}))])        keyboard.append(            [                Button(BUTTON_BACK, CommunityManagementMain,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ])        return keyboard    @register_button_handler    async def checkout_user(self, update, _context):        await get_payload_safe(self, update, _context, 'USER_STATS', 'CHANGE_USER_ROLE_ID')        cursor.execute('SELECT user_role_in_class FROM UserCommunities WHERE user_id = %s AND class_name = %s',                       (_context.user_data['CHANGE_USER_ROLE_ID'],                        _context.user_data['CURRENT_CLASS_NAME'],))        user_role = cursor.fetchall()        user_role = get_clean_var(user_role, 'to_string', 0, True)        _context.user_data['CHANGE_USER_ROLE_ROLE'] = user_role        return await UserRoleSelection().move(update, _context)class UserRoleSelection(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT name FROM Users WHERE id = %s', (_context.user_data['CHANGE_USER_ROLE_ID'],))        name = cursor.fetchall()        name = get_clean_var(name, 'to_string', 0, True)        return '<strong>Выберите новую роль для ' + name + ':</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        if _context.user_data['CHANGE_USER_ROLE_ROLE'] == 'ANONIM':            new_role = 'Администратор'        else:            new_role = 'Обычный пользователь'        keyboard.append([Button(new_role, self.change_role,                                source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                payload=dumps({'NEW_USER_ROLE': new_role}))])        keyboard.append([Button(BUTTON_BACK, CommunityUserChange,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def change_role(self, update, _context):        await get_payload_safe(self, update, _context, 'NEW_USER_ROLE_STATS', 'NEW_USER_ROLE')        if _context.user_data['NEW_USER_ROLE'] == 'Администратор':            new_role = 'ADMIN'        else:            new_role = 'ANONIM'        cursor.execute('UPDATE UserCommunities SET user_role_in_class = %s WHERE user_id = %s AND class_name = %s',                       (new_role, _context.user_data['CHANGE_USER_ROLE_ID'], _context.user_data['CURRENT_CLASS_NAME'],))        connection.commit()        return await show_notification_screen(update, _context, 'render',                                              '<strong>✅Роль пользователя успешно изменена!</strong>',                                              [                                                  [                                                      Button('Ещё изменить роли', CommunityUserChange,                                                             source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                  ],                                                  [                                                      Button('В панель управления сообществом', CommunityManagementMain,                                                             source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                  ],                                                  [                                                      Button(BUTTON_BACK_TO_MENU, MainMenu,                                                             source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                  ]                                              ])class CommunitiesMain(BaseScreen):    description = '<strong>Какое действие Вы хотите выполнить%s</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button('Создать своё сообщество ➕', self.go_create_community,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Зайти в существующее сообщество 😎', CommunityJoin,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, MainMenu,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_create_community(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_CLASS'        return await CommunityNameCreation().move(update, _context)class CommunityItemManagement(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + "_Items")        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>Выберите действие: </strong>'        else:            return '<strong>В сообществе пока нету предметов!</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + "_Items")        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            cursor.execute('SELECT main_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            main_name_list = cursor.fetchall()            cursor.execute('SELECT emoji FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            emoji_list = cursor.fetchall()            cursor.execute('SELECT rod_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            rod_name_list = cursor.fetchall()            cursor.execute('SELECT groups FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            groups_list = cursor.fetchall()            cursor.execute('SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            index_list = cursor.fetchall()            for i in range(db_length):                main_name = get_clean_var(main_name_list, 'to_string', i - 1, True)                emoji = get_clean_var(emoji_list, 'to_string', i - 1, True)                rod_name = get_clean_var(rod_name_list, 'to_string', i - 1, True)                groups = get_clean_var(groups_list, 'to_string', i - 1, True)                index = get_clean_var(index_list, 'to_string', i - 1, True)                keyboard.append(                    [Button(emoji + main_name, self.manage_item, source_type=SourceTypes.HANDLER_SOURCE_TYPE,                            payload=dumps({'MANAGE_ITEM_INDEX': index,                                           "MANAGE_ITEM_MAIN_NAME": main_name,                                           'MANAGE_ITEM_ROD_NAME': rod_name,                                           'MANAGE_ITEM_GROUPS': groups}))])        keyboard.append([Button(BUTTON_CREATE_ITEM, self.go_create_item,                                source_type=SourceTypes.HANDLER_SOURCE_TYPE)])        keyboard.append([Button(BUTTON_BACK, CommunityManagementMain,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def go_create_item(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_NAME'        return await CommunityItemNameAddition().move(update, _context)    @register_button_handler    async def manage_item(self, update, _context):        await get_payload_safe(self, update, _context, 'MANAGE_ITEM', "MANAGE_ITEM_INDEX")        await get_payload_safe(self, update, _context, 'MANAGE_ITEM', "MANAGE_ITEM_MAIN_NAME")        await get_payload_safe(self, update, _context, 'MANAGE_ITEM', "MANAGE_ITEM_ROD_NAME")        await get_payload_safe(self, update, _context, 'MANAGE_ITEM', "MANAGE_ITEM_GROUPS")        return await SchoolItemManagement().move(update, _context)class SchoolItemManagement(BaseScreen):    description = '<strong>Что Вы хотите сделать с данным предметом%s</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button('Изменить название предмета', self.change_name,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Изменить название предмета в дательном падеже', self.change_rod_name,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Изменить количество групп предмета', self.change_group_number,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Изменить эмодзи предмета', self.change_emoji,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button('Удалить предмет', SchoolItemDeletionConfirmation,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, CommunityItemManagement,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]    @register_button_handler    async def change_name(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_NAME'        return await SchoolItemNameChange().move(update, _context)    @register_button_handler    async def change_rod_name(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_ROD_NAME'        return await SchoolItemRodNameChange().move(update, _context)    @register_button_handler    async def change_group_number(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_GROUP_NUMBER'        return await SchoolItemGroupsChange().move(update, _context)    @register_button_handler    async def change_emoji(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_EMOJI'        return await SchoolItemEmojiChange().move(update, _context)class SchoolItemDeletionConfirmation(BaseScreen):    description = '<strong>Вы точно уверены, что хотите удалить данный предмет%s</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button('Удалить🗑️', self.delete_item,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, SchoolItemManagement,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]    @register_button_handler    async def delete_item(self, update, _context):        cursor.execute('DELETE FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE item_index = %s',                       (_context.user_data['MANAGE_ITEM_INDEX'],))        cursor.execute('DELETE FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks WHERE item_name = %s',                       (_context.user_data['MANAGE_ITEM_MAIN_NAME'],))        connection.commit()        return await show_notification_screen(update, _context, 'send', '<strong>Предмет был успешно удалён!</strong>',                                              [                                                  [Button('Вернуться в панель', CommunityItemManagement,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                   ],                                                  [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                   ]])class SchoolItemNameChange(BaseScreen):    description = '<strong>Введите новое название предмета: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await SchoolItemManagement().move(update, _context)class SchoolItemRodNameChange(BaseScreen):    description = '<strong>Введите новое название предмета в дательном падеже: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await SchoolItemManagement().move(update, _context)class SchoolItemGroupsChange(BaseScreen):    description = '<strong>Введите новое количество групп: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await SchoolItemManagement().move(update, _context)class SchoolItemEmojiChange(BaseScreen):    description = '<strong>Введите новый эмодзи, ассоциирующийся с предметом: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await SchoolItemManagement().move(update, _context)class CommunityItemEmojiAddition(BaseScreen):    description = '<strong>Введите эмоджи, ассоциирующийся с предметом: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_GROUP'        return await CommunityItemGroupAddition().move(update, _context)class CommunityItemNameAddition(BaseScreen):    description = '<strong>Введите название предмета: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await CommunityItemManagement().move(update, _context)class CommunityItemRodNameAddition(BaseScreen):    description = '<strong>Введите название предмета в дательном падеже: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_NAME'        return await CommunityItemNameAddition().move(update, _context)class CommunityItemGroupAddition(BaseScreen):    description = '<strong>Введите количество групп данного предмета:</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_ROD_NAME'        return await CommunityItemRodNameAddition().move(update, _context)class CommunityNameCreation(BaseScreen):    description = '<strong>Введите название Вашего сообщества: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await CommunitiesMain().move(update, _context)class CommunityPasswordCreation(BaseScreen):    description = '<strong>Введите пароль Вашего сообщества: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_CLASS'        return await CommunityNameCreation().move(update, _context)class CommunityJoin(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM Community')        community_count = cursor.fetchall()        community_count = get_clean_var(community_count, 'to_int', 0, True)        if community_count > 0:            return '<strong>Выберите интересующее Вас сообщество:</strong>'        else:            return '<strong>Пока что тут пусто!</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT COUNT(*) FROM Community')        check_length = cursor.fetchall()        check_length = get_clean_var(check_length, 'to_int', 0, True)        if check_length > 0:            cursor.execute('SELECT name FROM Community')            community_list = cursor.fetchall()            for community in range(check_length):                new_community = get_clean_var(community_list, 'to_string', community - 1, True)                keyboard.append([Button(new_community, self.go_enter_password,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ENTER_COMMUNITY_NAME': new_community}))])        keyboard.append([Button(BUTTON_BACK, CommunitiesMain,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def go_enter_password(self, update, _context):        await get_payload_safe(self, update, _context, 'GET_ENTER_COMMUNITY_NAME', 'ENTER_COMMUNITY_NAME')        cursor.execute('SELECT COUNT(*) FROM UserCommunities WHERE class_name = %s AND user_id = %s',                       (_context.user_data['ENTER_COMMUNITY_NAME'], update.effective_user.id,))        check_length = cursor.fetchall()        check_length = get_clean_var(check_length, 'to_int', 0, True)        if check_length < 1:            cursor.execute('SELECT password FROM Community WHERE name = %s',                           (_context.user_data['ENTER_COMMUNITY_NAME'],))            _context.user_data['ENTER_COMMUNITY_PASSWORD'] = cursor.fetchall()            _context.user_data['ENTER_COMMUNITY_PASSWORD'] = get_clean_var(                _context.user_data['ENTER_COMMUNITY_PASSWORD'], 'to_string', 0, True)            _context.user_data['CURRENT_TYPING_ACTION'] = 'WRITING_PASSWORD_TO_JOIN'            return await CommunityJoinPasswordEntry().move(update, _context)class CommunityJoinPasswordEntry(BaseScreen):    description = '<strong>Введите пароль сообщества: </strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await CommunityJoin().move(update, _context)class CarouselNotificationScreen(BaseScreen, BaseCarouselWidget):    callback_button_type = "main_menu"    callback_button_screen = MainMenu    hide_keyboard = Falseclass StaticNotificationScreen(BaseScreen):    hide_keyboard = Falseclass SocialMedia(BaseScreen):    description = '<strong>Подробнее о School Tasker Вы можете найти здесь:</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button('Наш новостной канал 📰', 'https://t.me/SchoolTaskerNews',                       source_type=SourceTypes.URL_SOURCE_TYPE)            ],            [                Button('Наш новостной канал в ВК 📰', 'https://vk.ru/schooltasker',                       source_type=SourceTypes.WEB_APP_SOURCE_TYPE)            ],            [                Button('Репозиторий бота в Github 🤖', 'https://github.com/TheDanskiSon09/School-Tasker',                       source_type=SourceTypes.WEB_APP_SOURCE_TYPE)            ],            [                Button('Связаться с разработчиком 📞', 'https://t.me/TheDanskiSon09',                       source_type=SourceTypes.URL_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK_TO_MENU, MainMenu,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]class WhatsNew(BaseScreen):    description = "_"    async def add_default_keyboard(self, update, _context):        return [            [                Button(BUTTON_BACK_TO_MENU, MainMenu, source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]    async def get_description(self, update, _context):        current_day = datetime.now().day        current_month = datetime.now().month        try:            title = str()            title += "<strong>"            month_dict = {1: MONTH_JAN,                          2: MONTH_FEB,                          3: MONTH_MARCH,                          4: MONTH_APRIL,                          5: MONTH_MAY,                          6: MONTH_JUNE,                          7: MONTH_JULY,                          8: MONTH_AUG,                          9: MONTH_SEP,                          10: MONTH_OCT,                          11: MONTH_NOV,                          12: MONTH_DEC}            month = month_dict[current_month]            title += str(month[current_day])            title += "</strong>"            return title        except KeyError:            return "<strong>Сегодня никаких праздников и мероприятий</strong>"class Options(BaseScreen):    description = '<strong>Выберите подходящие для Вас параметры</strong>'    async def add_default_keyboard(self, update, _context):        user_id = update.effective_user.id        notification_button_title = str()        cursor.execute("SELECT send_notification FROM Users WHERE id = %s", (user_id, ))        notification_permission = cursor.fetchone()        notification_permission = get_clean_var(notification_permission, "to_int", False, True)        if notification_permission == 0:            notification_button_title = "Включить "        if notification_permission == 1:            notification_button_title = "Выключить "        notification_button_title += "рассылки от бота"        return [            [                Button(notification_button_title, self.edit_notification_permission,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE,                       payload=dumps({"index": notification_permission}))            ],            [                Button(BUTTON_BACK_TO_MENU, MainMenu,                       source_type=SourceTypes.MOVE_SOURCE_TYPE),            ],        ]    @register_button_handler    async def edit_notification_permission(self, update, _context):        await get_payload_safe(self, update, _context, "options", "index")        notification_permission = _context.user_data['index']        if notification_permission == 1:            notification_permission = 0        else:            notification_permission = 1        user = update.effective_user        cursor.execute(            'UPDATE Users set send_notification = %s WHERE id = %s', (notification_permission, user.id))        connection.commit()        return await self.move(update, _context)class SchoolTasks(BaseScreen):    back_button = Button('_', CommunitySelectionToWatch, source_type=SourceTypes.MOVE_SOURCE_TYPE)    async def check_tasks(self, update, _context, target_screen):        new_config = RenderConfig()        new_config.keyboard = []        Global.index_store = await get_var_from_database(None, "database_length_SchoolTasker", True, _context)        database_length = Global.index_store        title = str()        if database_length < 1:            if target_screen:                target_screen.description = "<strong>На данный момент список заданий пуст!</strong>"                new_config.keyboard = [[self.back_button]]                return await target_screen().render(update, _context, config=new_config)        else:            Global.open_date = True            new_title = str()            tasks_to_delete = []            for i in range(database_length):                title, current_title, check_day, check_month, check_year = await get_multipy_async(i, title, _context)                if check_year == datetime.now().year:                    if check_month == datetime.now().month:                        if check_day <= datetime.now().day:                            title = ""                            cursor.execute("SELECT item_index FROM " + _context.user_data[                                'CURRENT_CLASS_NAME'] + "_Tasks ORDER BY hypertime ASC")                            del_index = cursor.fetchall()                            del_index = get_clean_var(del_index, "to_string", i, True)                            if del_index not in tasks_to_delete:                                tasks_to_delete.append(del_index)                    if check_month < datetime.now().month:                        title = ""                        cursor.execute("SELECT item_index FROM " + _context.user_data[                            'CURRENT_CLASS_NAME'] + "_Tasks ORDER BY hypertime ASC")                        del_index = cursor.fetchall()                        del_index = get_clean_var(del_index, "to_string", i, True)                        if del_index not in tasks_to_delete:                            tasks_to_delete.append(del_index)                if check_year < datetime.now().year:                    title = ""                    cursor.execute("SELECT item_index FROM " + _context.user_data[                        'CURRENT_CLASS_NAME'] + "_Tasks ORDER BY hypertime ASC")                    del_index = cursor.fetchall()                    del_index = get_clean_var(del_index, "to_string", i, True)                    if del_index not in tasks_to_delete:                        tasks_to_delete.append(del_index)                else:                    new_title = title                    Global.open_date = False                    cursor.execute("SELECT item_index FROM " + _context.user_data[                        'CURRENT_CLASS_NAME'] + "_Tasks ORDER BY hypertime ASC")                    media_index = cursor.fetchall()                    media_index = get_clean_var(media_index, "to_string", i, True)                    if exists(str(settings.MEDIA_ROOT) + "/" + media_index) and media_index not in tasks_to_delete:                        media_button_title = str()                        cursor.execute('SELECT item_name FROM ' + _context.user_data[                            'CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s', (media_index,))                        media_item_name = cursor.fetchone()                        media_item_name = get_clean_var(media_item_name, 'to_string', False, True)                        media_button_title += "🖼" + media_item_name                        cursor.execute('SELECT groups FROM ' + _context.user_data[                            'CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',                                       (media_item_name,))                        groups_check = cursor.fetchone()                        groups_check = get_clean_var(groups_check, 'to_string', 0, True)                        if int(groups_check) > 1:                            cursor.execute('SELECT group_number FROM ' + _context.user_data[                                'CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',                                           (media_index,))                            media_group_number = cursor.fetchone()                            media_group_number = get_clean_var(media_group_number, 'to_string', False,                                                               True)                            media_button_title += '(' + media_group_number + "ая группа)"                        media_button_title += ': '                        cursor.execute('SELECT task_description FROM ' + _context.user_data[                            'CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',                                       (media_index,))                        media_task_description = cursor.fetchone()                        media_task_description = get_clean_var(media_task_description, 'to_string',                                                               False, False)                        media_button_title += media_task_description                        new_config.keyboard.append([Button(media_button_title, self._goto_task_media,                                                           source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                                           payload=dumps({"MEDIA_INDEX_GOTO": media_index,                                                                          'MEDIA_TITLE': current_title}))])                if not new_title:                    if target_screen:                        target_screen.description = "<strong>На данный момент список заданий пуст!</strong>"                else:                    if target_screen:                        target_screen.description = new_title            for task_id in tasks_to_delete:                await logger_alert([], "delete", task_id, False, _context)                cursor.execute(                    'DELETE FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',                    (task_id,))                connection.commit()                if exists(str(settings.MEDIA_ROOT) + '/' + task_id + '/'):                    rmtree(str(settings.MEDIA_ROOT) + '/' + task_id)            else:                if target_screen:                    target_screen.description = new_title            if database_length < 1:                if target_screen:                    target_screen.description = "<strong>На данный момент список заданий пуст!</strong>"            if target_screen:                new_config.keyboard.append([self.back_button])                try:                    return await target_screen().render(update, _context, config=new_config)                except ScreenDescriptionIsEmpty:                    bad_config = RenderConfig()                    bad_config.description = '<strong>На данный момент список заданий пуст!</strong>'                    bad_config.keyboard = [[self.back_button]]                    return await target_screen().render(update, _context, config=bad_config)                except BadRequest:                    for x in range(0, len(target_screen.description), settings.MAX_CAPTION_LENGTH):                        current_description = target_screen.description[x:x + settings.MAX_CAPTION_LENGTH]                        save_markers = save_html_markers(current_description)                        soup = BeautifulSoup(save_markers, "html.parser")                        soup.prettify()                        current_description = str(soup)                        current_description = load_html_markers(current_description)                        current_description = "<strong>" + current_description + '</strong>'                        if x + settings.MAX_CAPTION_LENGTH >= len(target_screen.description):                            new_config.description = current_description                            return await target_screen().send(_context, config=new_config)                        else:                            await update.effective_chat.send_message(current_description, parse_mode='HTML')    @register_button_handler    async def _goto_task_media(self, update, _context):        await get_payload_safe(self, update, _context, "task_media_index", 'MEDIA_INDEX_GOTO')        await get_payload_safe(self, update, _context, "task_media_index", 'MEDIA_TITLE')        try:            show_images = listdir('media/' + _context.user_data['MEDIA_INDEX_GOTO'] + "/")            if len(show_images) > 1:                new_task_media = CarouselTaskMedia()            else:                new_task_media = StaticTaskMedia()            new_task_media.images = []            for image in show_images:                path = _context.user_data['MEDIA_INDEX_GOTO'] + '/' + image                item = [settings.MEDIA_ROOT / path, _context.user_data['MEDIA_TITLE']]                new_task_media.images.append(item)            new_config = RenderConfig()            if len(show_images) == 1:                new_task_media.current_images = new_task_media.images[0]                new_task_media.cover = new_task_media.current_images[0]                new_task_media.description = _context.user_data['MEDIA_TITLE']                new_config.keyboard = [                    [                        Button(BUTTON_BACK, self._static_check_tasks,                               source_type=SourceTypes.HANDLER_SOURCE_TYPE)                    ]                ]                try:                    return await new_task_media.render(update, _context, config=new_config)                except BadRequest:                    for x in range(0, len(new_task_media.description), settings.MAX_CAPTION_LENGTH):                        current_description = new_task_media.description[x:x + settings.MAX_CAPTION_LENGTH]                        save_markers = save_html_markers(current_description)                        soup = BeautifulSoup(save_markers, "html.parser")                        soup.prettify()                        current_description = str(soup)                        current_description = load_html_markers(current_description)                        current_description = "<strong>" + current_description + '</strong>'                        if x + settings.MAX_CAPTION_LENGTH >= len(new_task_media.description):                            new_config.description = current_description                            return await new_task_media.send(_context, config=new_config)                        else:                            await update.effective_chat.send_message(current_description, parse_mode='HTML')            else:                try:                    return await new_task_media.move(update, _context)                except BadRequest:                    for x in range(0, len(new_task_media.description), settings.MAX_CAPTION_LENGTH):                        current_description = new_task_media.description[x:x + settings.MAX_CAPTION_LENGTH]                        save_markers = save_html_markers(current_description)                        soup = BeautifulSoup(save_markers, "html.parser")                        soup.prettify()                        current_description = str(soup)                        current_description = load_html_markers(current_description)                        current_description = "<strong>" + current_description + '</strong>'                        if x + settings.MAX_CAPTION_LENGTH >= len(new_task_media.description):                            new_config.description = current_description                            return await new_task_media.send(_context, config=new_config)                        else:                            await update.effective_chat.send_message(current_description, parse_mode='HTML')        except FileNotFoundError:            await SchoolTasks().check_tasks(update, _context, SchoolTasks)    @register_button_handler    async def _static_check_tasks(self, update, context):        new_st_screen = SchoolTasks        return await self.check_tasks(update, context, new_st_screen)class CarouselTaskMedia(BaseScreen, BaseCarouselWidget):    images = [        [settings.MEDIA_ROOT / "logo.webp", "_"]    ]    callback_button_type = 'school_tasks'    callback_button_screen = SchoolTasks    button_title = "⬅На главный экран"class StaticTaskMedia(BaseScreen):    passclass OldTaskAdditionAlert(BaseScreen):    description = ("<strong>⚠Внимание!\nВы ввели дату и месяц задания, которые уже считаются устаревшими!"                   " Если Вы добавите задание с данными характеристиками, оно будет удалено при"                   " первом заходе в задачник!"                   "\nВы точно хотите добавить данное задание%s</strong>")    task_args = list()    task_context = str()    current_index = int()    async def get_description(self, update, _context):        if self.task_context == "add":            word00 = "добавите "            word01 = "добавить "        elif self.task_context == "change":            word00 = "измените "            word01 = "изменить "        else:            word00 = ""            word01 = ""        part00 = "<strong>⚠Внимание!\nВы ввели дату и месяц задания, которые уже считаются устаревшими."        part01 = " Если Вы " + word00 + ('задание с данными характеристиками, оно будет удалено при первом заходе в'                                         ' задачник!')        part02 = "\nВы точно хотите " + word01 + "данное задание%s</strong>"        return part00 + part01 + part02    async def add_default_keyboard(self, update, _context):        keyboard = []        if self.task_context == "add":            keyboard.append([                Button("Добавить данное задание➕", self.add_old_task, source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ])        elif self.task_context == "change":            keyboard.append([                Button("Изменить данное задание✖", self.change_task, source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ])        keyboard.append([            Button("⬅️ Изменить дату/месяц задания", self.change_task_time,                   source_type=SourceTypes.HANDLER_SOURCE_TYPE)        ])        keyboard.append([            Button("⬅️ В меню редактора", SchoolTaskManagementMain, source_type=SourceTypes.MOVE_SOURCE_TYPE)        ])        return keyboard    @register_button_handler    async def change_task_time(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGE_TASK_TIME'        return await SchoolTaskAdditionDetails().move(update, _context)    @register_button_handler    async def add_old_task(self, update, _context):        _context.user_data["ADD_TASK_ITEM_INDEX"] = str(generate_id())        await add_task_school(update, _context, self.task_args[0], self.task_args[1], self.task_args[2],                              self.task_args[3], self.task_args[4], self.task_args[5])    @register_button_handler    async def change_task(self, update, _context):        self.task_args[5] = datetime.now().year        cursor.execute('UPDATE SchoolTasker set task_day = %s, task_month = %s, task_year = %s WHERE item_index = %s',                       (self.task_args[3], self.task_args[4], self.task_args[5], self.current_index,))        connection.commit()        hypertime = get_hypertime(self.task_args[4], self.task_args[3], self.task_args[5])        cursor.execute("UPDATE SchoolTasker set hypertime = %s WHERE item_index = %s",                       (hypertime, self.current_index,))        connection.commit()        await send_update_notification(update, _context, "change", self.current_index, False)        return await show_notification_screen(update, _context, 'send', "✅<strong>Задание успешно изменено!</strong>",                                              [                                                  [Button('⬅️ В меню редактора', SchoolTaskManagementMain,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                  [Button("⬅ Изменить ещё задания", SchoolTaskChangeMain,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                  [Button('⬅️ На главный экран', MainMenu,                                                          source_type=SourceTypes.MOVE_SOURCE_TYPE)]])class SchoolTaskManagementMain(BaseScreen):    description = '<strong>Какие изменения Вы хотите внести в задачник%s</strong>'    async def add_default_keyboard(self, update, _context):        return [            [                Button('Добавить задание➕', SchoolTaskAddition,                       source_type=SourceTypes.MOVE_SOURCE_TYPE),            ],            [                Button('Изменить задание✖', SchoolTaskChangeMain,                       source_type=SourceTypes.MOVE_SOURCE_TYPE),            ],            [                Button('Удалить задание➖', SchoolTaskRemoval,                       source_type=SourceTypes.MOVE_SOURCE_TYPE),            ],            [                Button(BUTTON_BACK_TO_MENU, MainMenu,                       source_type=SourceTypes.MOVE_SOURCE_TYPE),            ],        ]class SchoolTaskAddition(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>По какому предмету будет задание%s</strong>'        else:            return '<strong>В сообществе пока нету предметов!</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            cursor.execute('SELECT main_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            main_name_list = cursor.fetchall()            cursor.execute('SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            item_index_list = cursor.fetchall()            cursor.execute('SELECT groups FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            groups_list = cursor.fetchall()            cursor.execute('SELECT emoji FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            emoji_list = cursor.fetchall()            for i in range(db_length):                main_name = get_clean_var(main_name_list, 'to_string', i - 1, True)                item_index = get_clean_var(item_index_list, 'to_string', i - 1, True)                groups = get_clean_var(groups_list, 'to_string', i - 1, True)                emoji = get_clean_var(emoji_list, 'to_string', i - 1, True)                keyboard.append([Button(emoji + main_name, self.get_school_item,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ADDING_TASK_NAME': main_name,                                                       'ADDING_TASK_INDEX': item_index,                                                       'ADDING_TASK_GROUPS': groups}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskManagementMain,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_school_item(self, update, _context):        await get_payload_safe(self, update, _context, 'add_task_item', 'ADDING_TASK_NAME')        await get_payload_safe(self, update, _context, 'add_task_item', 'ADDING_TASK_GROUPS')        await get_payload_safe(self, update, _context, 'add_task_item', 'ADDING_TASK_INDEX')        if int(_context.user_data['ADDING_TASK_GROUPS']) > 1:            return await SchoolTaskAdditionGroupNumber().move(update, _context)        else:            _context.user_data['CURRENT_TYPING_ACTION'] = 'ADDING_TASK'            return await SchoolTaskAdditionDetails().move(update, _context)class SchoolTaskAdditionGroupNumber(BaseScreen):    description = '<strong>Какой группе дано задание%s</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        for i in range(int(_context.user_data['ADDING_TASK_GROUPS'])):            keyboard.append([Button('Группа ' + str(i + 1), self.get_group_number,                                    source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                    payload=dumps({'ADDING_TASK_GROUP_NUMBER': str(i + 1)}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAddition, source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_group_number(self, update, _context):        await get_payload_safe(self, update, _context, 'add_task_group_number', 'ADDING_TASK_GROUP_NUMBER')        _context.user_data['CURRENT_TYPING_ACTION'] = 'ADDING_TASK'        return await SchoolTaskAdditionDetails().move(update, _context)    @register_button_handler    async def return_back(self, update, _context):        return await SchoolTaskAddition().move(update, _context)async def go_to_alert(task_args: list, task_context: str, current_index, update, _context):    OldTaskAdditionAlert().task_context = task_context    OldTaskAdditionAlert.task_args = task_args    OldTaskAdditionAlert().current_index = current_index    return await OldTaskAdditionAlert().jump(update, _context)class SchoolTaskAdditionDetails(BaseScreen):    description = '<strong>Введите текст задания:</strong>'    async def add_default_keyboard(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'ADDING_TASK'        return [            [                Button(BUTTON_BACK, self.return_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE),            ],        ]    @register_button_handler    async def return_back(self, update, _context):        if _context.user_data['CURRENT_TYPING_ACTION'] == "CHANGING_MONTH" or _context.user_data[            'CURRENT_TYPING_ACTION'] == 'CHANGING_TASK_DESCRIPTION' or _context.user_data[            'CURRENT_TYPING_ACTION'] == 'CHANGING_GROUP_NUMBER' or _context.user_data[            'CURRENT_TYPING_ACTION'] == 'CHANGING_DAY':            _context.user_data['CURRENT_TYPING_ACTION'] = ''            return await SchoolTaskChangeBase().move(update, _context)        else:            _context.user_data['CURRENT_TYPING_ACTION'] = ''            return await SchoolTaskAddition().move(update, _context)    @register_typing_handler    async def set_details(self, update, _context):        if _context.user_data['CURRENT_TYPING_ACTION'] == 'ADDING_TASK':            _context.user_data["ADDING_TASK_TASK_DESCRIPTION"] = update.message.text            return await SchoolTaskAdditionDetailsMonth().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_TASK_DESCRIPTION':            _context.user_data['ADDING_TASK_TASK_DESCRIPTION'] = update.message.text            _context.user_data['CURRENT_TYPING_ACTION'] = ''            check_task = await check_task_status(_context)            if not check_task:                return await show_notification_screen(update, _context, 'send',                                                      "<strong>Я не могу выполнить Ваш запрос - пожалуйста, повторите "                                                      "попытку</strong>",                                                      [                                                          [Button("🔄Повторить попытку", SchoolTaskManagementMain,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ],                                                          [Button(BUTTON_BACK, SchoolTaskManagementMain,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ]])            else:                cursor.execute(                    'UPDATE ' + _context.user_data[                        'CURRENT_CLASS_NAME'] + '_Tasks SET task_description = %s WHERE item_index = %s',                    (_context.user_data['ADDING_TASK_TASK_DESCRIPTION'], _context.user_data['ADDING_TASK_INDEX'],))                connection.commit()                cursor.execute(                    'SELECT item_name FROM ' + _context.user_data[                        'CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',                    (_context.user_data['ADDING_TASK_INDEX'],))                item_name = cursor.fetchall()                item_name = get_clean_var(item_name, 'to_string', 0, True)                cursor.execute(                    'SELECT item_index FROM ' + _context.user_data[                        'CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',                    (item_name,))                _context.user_data['ADDING_TASK_INDEX'] = cursor.fetchall()                _context.user_data['ADDING_TASK_INDEX'] = get_clean_var(_context.user_data['ADDING_TASK_INDEX'],                                                                        'to_string', 0, True)                return await send_update_notification(update, _context, 'change',                                                      _context.user_data['ADDING_TASK_INDEX'],                                                      True)        elif _context.user_data['CURRENT_TYPING_ACTION'] == "CREATING_CLASS":            _context.user_data['CURRENT_CLASS_NAME'] = update.message.text            _context.user_data['CURRENT_CLASS_NAME'] = _context.user_data['CURRENT_CLASS_NAME'].replace(' ', '')            _context.user_data['CURRENT_TYPING_ACTION'] = 'ADDING_PASSWORD_TO_CLASS'            return await CommunityPasswordCreation().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'ADDING_PASSWORD_TO_CLASS':            _context.user_data['CURRENT_CLASS_PASSWORD'] = update.message.text            _context.user_data['CURRENT_TYPING_ACTION'] = ''            cursor.execute('INSERT INTO Community (name, password) VALUES (%s,%s)',                           (_context.user_data['CURRENT_CLASS_NAME'], _context.user_data['CURRENT_CLASS_PASSWORD']))            connection.commit()            cursor.execute('''            CREATE TABLE IF NOT EXISTS ''' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks' + ''' (            item_name TEXT,            item_index TEXT,            group_number TEXT,            task_description TEXT,            task_day TEXT,            task_month TEXT,            task_year TEXT,            hypertime TEXT            )            ''')            cursor.execute('''                                            CREATE TABLE IF NOT EXISTS ''' + _context.user_data[                'CURRENT_CLASS_NAME'] + '_Items' + ''' (                                            item_index TEXT,                                            emoji TEXT UNIQUE,                                            main_name TEXT UNIQUE,                                            rod_name TEXT UNIQUE,                                            groups TEXT                                            )                                            ''')            cursor.execute('INSERT INTO UserCommunities (user_id, class_name, user_role_in_class) VALUES (%s,%s,%s)',                           (update.message.chat.id, _context.user_data['CURRENT_CLASS_NAME'], "HOST"))            connection.commit()            return await show_notification_screen(update, _context, 'send',                                                  '<strong>Ваше сообщество было создано! Не забудьте добавить к нему '                                                  'школьные предметы,'                                                  'чтобы Вы и администраторы смогли добавлять задания!</strong>', [                                                      [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CREATING_ITEM_NAME':            _context.user_data['CREATING_ITEM_NAME'] = update.message.text            _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_ROD_NAME'            return await CommunityItemRodNameAddition().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CREATING_ITEM_ROD_NAME':            _context.user_data['CREATING_ITEM_ROD_NAME'] = update.message.text            _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_GROUP'            return await CommunityItemGroupAddition().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CREATING_ITEM_GROUP':            try:                _context.user_data['CREATING_ITEM_GROUPS'] = int(update.message.text)            except ValueError:                return await CommunityItemGroupAddition().jump(update, _context)            _context.user_data['CREATING_ITEM_GROUPS'] = update.message.text            _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_EMOJI'            return await CommunityItemEmojiAddition().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CREATING_ITEM_EMOJI':            if len(update.message.text) - 1 == 1 and is_emoji(update.message.text):                _context.user_data['CURRENT_TYPING_ACTION'] = ''                _context.user_data['CREATING_ITEM_EMOJI'] = update.message.text                cursor.execute('INSERT INTO ' + _context.user_data[                    'CURRENT_CLASS_NAME'] + '_Items (item_index, emoji, main_name, rod_name, groups) VALUES (%s, %s, %s, '                                            '%s, %s)',                               (generate_id(), _context.user_data['CREATING_ITEM_EMOJI'],                                _context.user_data['CREATING_ITEM_NAME'],                                _context.user_data['CREATING_ITEM_ROD_NAME'],                                _context.user_data['CREATING_ITEM_GROUPS']), )                connection.commit()                return await show_notification_screen(update, _context, 'send',                                                      '<strong>Ваш прдемет успешно создан и добавлен в Ваш '                                                      'класс!</strong>',                                                      [                                                          [Button('Создать ещё предмет', self.go_create_more_items,                                                                  source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                           ],                                                          [Button('В центральное меню', CommunityItemManagement,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ],                                                          [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ]])            else:                return await CommunityItemEmojiAddition().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_CLASS_NAME':            new_community_name = update.message.text.replace(' ', '')            cursor.execute('UPDATE Community SET name = %s WHERE name = %s',                           (new_community_name, _context.user_data['CURRENT_CLASS_NAME'],))            cursor.execute('UPDATE UserCommunities SET class_name = %s WHERE class_name = %s',                           (new_community_name, _context.user_data['CURRENT_CLASS_NAME'],))            with suppress(OperationalError):                cursor.execute('ALTER TABLE ' + _context.user_data[                    'CURRENT_CLASS_NAME'] + '_Items RENAME TO ' + new_community_name + '_Items')                cursor.execute('ALTER TABLE ' + _context.user_data[                    'CURRENT_CLASS_NAME'] + '_Tasks RENAME TO ' + new_community_name + '_Tasks')                connection.commit()            _context.user_data['CURRENT_CLASS_NAME'] = new_community_name            _context.user_data['CURRENT_TYPING_ACTION'] = ''            return await show_notification_screen(update, _context, 'send',                                                  '<strong>Название Вашего сообщества успешно изменено!</strong>', [                                                      [Button('Ещё раз изменить название сообщества',                                                              self.go_change_name,                                                              source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                       ],                                                      [Button('В панель управления сообществом',                                                              CommunityManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_CLASS_PASSWORD':            cursor.execute('UPDATE Community set password = %s WHERE name = %s',                           (update.message.text, _context.user_data['CURRENT_CLASS_NAME'],))            connection.commit()            return await show_notification_screen(update, _context, 'send',                                                  '<strong>Пароль Вашего сообщества был успешно изменён!</strong>',                                                  [                                                      [Button('Ещё раз изменить пароль сообщества',                                                              self.go_change_password,                                                              source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                       ],                                                      [Button('В панель управления сообществом',                                                              CommunityManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_ITEM_NAME':            cursor.execute('UPDATE ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items SET main_name = %s',                           (update.message.text,))            cursor.execute('UPDATE ' + _context.user_data[                'CURRENT_CLASS_NAME'] + '_Tasks SET item_name = %s WHERE item_index = %s',                           (update.message.text, _context.user_data['MANAGE_ITEM_INDEX'],))            connection.commit()            _context.user_data['CURRENT_TYPING_ACTION'] = ''            return await show_notification_screen(update, _context, 'send',                                                  '<strong>Название предмета успешно изменено!</strong>', [                                                      [                                                          Button('Ещё раз изменить название предмета',                                                                 self.go_change_item_name,                                                                 source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                      ],                                                      [                                                          Button('В панель управления предметом', SchoolItemManagement,                                                                 source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                      ],                                                      [                                                          Button('В панель управления сообществом',                                                                 CommunityManagementMain,                                                                 source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                      ],                                                      [                                                          Button(BUTTON_BACK_TO_MENU, MainMenu,                                                                 source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                      ]                                                  ])        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_ITEM_ROD_NAME':            cursor.execute('UPDATE ' + _context.user_data[                'CURRENT_CLASS_NAME'] + '_Items SET rod_name = %s WHERE item_index = %s',                           (update.message.text, _context.user_data['MANAGE_ITEM_INDEX']))            connection.commit()            _context.user_data['CURRENT_TYPING_ACTION'] = ''            return await show_notification_screen(update, _context, 'send',                                                  '<strong>Название предмета в дательном падеже успешно '                                                  'изменено!</strong>',                                                  [                                                      [Button(                                                          'Ещё раз изменить название предмета в дательном падеже',                                                          self.go_change_rod_name,                                                          source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                      ],                                                      [Button('В панель управления предметом', SchoolItemManagement,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button('В панель управления сообществом',                                                              CommunityManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_ITEM_GROUPS':            try:                new_group_number = int(update.message.text)                if new_group_number > 0:                    cursor.execute('UPDATE ' + _context.user_data[                        'CURRENT_CLASS_NAME'] + '_Items SET groups = %s WHERE item_index = %s',                                   (update.message.text, _context.user_data['MANAGE_ITEM_INDEX'],))                    connection.commit()                    _context.user_data['CURRENT_TYPING_ACTION'] = ''                    return await show_notification_screen(update, _context, 'send',                                                          '<strong>Количество предмета было успешно изменено!</strong>',                                                          [                                                              [Button('Ещё раз изменить количество групп предмета',                                                                      self.go_change_groups,                                                                      source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                               ],                                                              [Button('В панель управления предметом',                                                                      SchoolItemManagement,                                                                      source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                               ],                                                              [Button('В панель управления сообществом',                                                                      CommunityManagementMain,                                                                      source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                               ],                                                              [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                                      source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                               ]                                                          ])                else:                    return await SchoolItemGroupsChange().jump(update, _context)            except ValueError:                return await SchoolItemGroupsChange().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'CHANGING_ITEM_EMOJI':            if len(update.message.text) - 1 == 1 and is_emoji(update.message.text):                _context.user_data['CURRENT_TYPING_ACTION'] = ''                cursor.execute('UPDATE ' + _context.user_data[                    'CURRENT_CLASS_NAME'] + '_Items SET emoji = %s WHERE item_index = %s',                               (update.message.text, _context.user_data['MANAGE_ITEM_INDEX']))                connection.commit()                return await show_notification_screen(update, _context, 'send',                                                      '<strong>Эмодзи предмета был успешно изменён!</strong>', [                                                          [Button('Ещё раз изменить эмодзи предмета',                                                                  self.go_change_emoji,                                                                  source_type=SourceTypes.HANDLER_SOURCE_TYPE)                                                           ],                                                          [Button('В панель управления предметом', SchoolItemManagement,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ],                                                          [Button('В панель управления сообществом',                                                                  CommunityManagementMain,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ],                                                          [Button(BUTTON_BACK_TO_MENU, MainMenu,                                                                  source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                           ]                                                      ])            else:                return await SchoolItemEmojiChange().jump(update, _context)        elif _context.user_data['CURRENT_TYPING_ACTION'] == 'WRITING_PASSWORD_TO_JOIN':            if update.message.text == _context.user_data['ENTER_COMMUNITY_PASSWORD']:                cursor.execute(                    'INSERT INTO UserCommunities (user_id, class_name, user_role_in_class) VALUES (%s,%s,%s)',                    (update.effective_user.id, _context.user_data['ENTER_COMMUNITY_NAME'], 'ANONIM'))                connection.commit()                _context.user_data['CURRENT_TYPING_ACTION'] = ''                return await show_notification_screen(update, _context, 'send', '✅ Вы успешно зашли в сообщество!', [                    [                        Button('Ещё присоединиться', CommunityJoin,                               source_type=SourceTypes.MOVE_SOURCE_TYPE)                    ],                    [                        Button('В экран сообществ', CommunitiesMain,                               source_type=SourceTypes.MOVE_SOURCE_TYPE)                    ],                    [                        Button(BUTTON_BACK_TO_MENU, MainMenu,                               source_type=SourceTypes.MOVE_SOURCE_TYPE)                    ]                ])            else:                return await CommunityJoinPasswordEntry().jump(update, _context)    @register_button_handler    async def go_create_more_items(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CREATING_ITEM_NAME'        return await CommunityItemNameAddition().move(update, _context)    @register_button_handler    async def go_change_name(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_CLASS_NAME'        return await CommunityNameChange().move(update, _context)    @register_button_handler    async def go_change_rod_name(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_ROD_NAME'        return await SchoolItemRodNameChange().move(update, _context)    @register_button_handler    async def go_change_password(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_CLASS_PASSWORD'        return await CommunityPasswordChange().move(update, _context)    @register_button_handler    async def go_change_item_name(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_NAME'        return await SchoolItemNameChange().move(update, _context)    @register_button_handler    async def go_change_groups(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_GROUPS'        return await SchoolItemGroupsChange().move(update, _context)    @register_button_handler    async def go_change_emoji(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_ITEM_EMOJI'        return await SchoolItemEmojiChange().move(update, _context)class MediaCapture(BaseScreen):    description = '<strong>Отправьте в чат фотографии, которые нужно закрепить к заданию: </strong>'    @register_input_handler    async def catch_media(self, update, _context):        if update.message.text and update.message.text == '/start':            return await MainMenu().jump(update, _context)        with suppress(KeyError):            if _context.user_data["IS_IN_MEDIA_SCREEN"]:                message = update.message                if message.photo:                    file = message.photo[-1]                    file_id = file.file_id                    file = await _context.bot.get_file(file_id)                    try:                        _context.user_data["MEDIA_ADD"].append(file)                    except KeyError:                        _context.user_data["MEDIA_ADD"] = []                        _context.user_data["MEDIA_ADD"].append(file)                    new_config = RenderConfig()                    new_config.description = "✅<strong>Успешно получено! Что вы ещё хотите сделать%s</strong>"                    new_config.keyboard = [                        [                            Button("Создать задание➕", self.add_school_task,                                   source_type=SourceTypes.HANDLER_SOURCE_TYPE)                        ],                        [                            Button("Удалить присланные фотографии🗑️", self.delete_media,                                   source_type=SourceTypes.HANDLER_SOURCE_TYPE)                        ],                        [                            Button(BUTTON_BACK, self.go_to_task_screen,                                   source_type=SourceTypes.HANDLER_SOURCE_TYPE)                        ]                    ]                    return await MediaCapture().send(_context, config=new_config, extra_data=None)    @register_button_handler    async def go_to_task_screen(self, update, _context):        _context.user_data["MEDIA_ADD"] = []        return await SchoolTaskAddition().move(update, _context)    @register_button_handler    async def delete_media(self, _update, _context):        new_config = RenderConfig()        new_config.description = '<strong>Вы точно уверены, что хотите удалить присланные Вами изображения%s</strong>'        new_config.keyboard = [            [                Button('Удалить 🗑️', self.confirm_delete,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]        return await MediaCapture().send(_context, config=new_config, extra_data=None)    @register_button_handler    async def go_back(self, _update, _context):        new_config = RenderConfig()        new_config.description = self.description        new_config.keyboard = [            [                Button("Создать задание➕", self.add_school_task,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button("Удалить присланные фотографии🗑️", self.delete_media,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, self.go_to_task_screen,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]        return await MediaCapture().send(_context, config=new_config, extra_data=None)    @register_button_handler    async def confirm_delete(self, _update, _context):        _context.user_data["MEDIA_ADD"] = []        new_config = RenderConfig()        new_config.description = "✅<strong>Фотографии успешно удалены! Что вы ещё хотите сделать%s</strong>"        new_config.keyboard = [            [                Button("Создать задание➕", self.add_school_task,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, self.go_to_task_screen,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]        return await MediaCapture().send(_context, config=new_config, extra_data=None)    @register_button_handler    async def add_school_task(self, update, _context):        check = check_task_validity(int(_context.user_data["ADDING_TASK_TASK_DAY"]),                                    _context.user_data["ADDING_TASK_TASK_MONTH"],                                    _context.user_data["ADDING_TASK_TASK_YEAR"])        _context.user_data["ADD_TASK_ITEM_INDEX"] = str(generate_id())        if check:            try:                try:                    await add_task_school(update, _context, _context.user_data["ADDING_TASK_NAME"],                                          _context.user_data["ADDING_TASK_TASK_DESCRIPTION"],                                          _context.user_data["ADDING_TASK_GROUP_NUMBER"],                                          int(_context.user_data["ADDING_TASK_TASK_DAY"]),                                          int(_context.user_data["ADDING_TASK_TASK_MONTH"]),                                          int(_context.user_data["ADDING_TASK_TASK_YEAR"]))                except KeyError:                    await add_task_school(update, _context, _context.user_data["ADDING_TASK_NAME"],                                          _context.user_data["ADDING_TASK_TASK_DESCRIPTION"],                                          1,                                          int(_context.user_data["ADDING_TASK_TASK_DAY"]),                                          int(_context.user_data["ADDING_TASK_TASK_MONTH"]),                                          int(_context.user_data["ADDING_TASK_TASK_YEAR"]))            except KeyError:                await add_task_school(update, _context, _context.user_data["ADDING_TASK_NAME"],                                      _context.user_data["ADDING_TASK_TASK_DESCRIPTION"],                                      1,                                      int(_context.user_data["ADDING_TASK_TASK_DAY"]),                                      int(_context.user_data["ADDING_TASK_TASK_MONTH"]),                                      int(_context.user_data["ADDING_TASK_TASK_YEAR"]))        else:            await go_to_alert([_context.user_data["ADDING_TASK_NAME"],                               _context.user_data["ADDING_TASK_TASK_DESCRIPTION"],                               _context.user_data["ADDING_TASK_GROUP_NUMBER"],                               _context.user_data["ADDING_TASK_TASK_DAY"],                               _context.user_data["ADDING_TASK_TASK_MONTH"],                               _context.user_data["ADDING_TASK_TASK_YEAR"]],                              "add", _context.user_data['ADD_TASK_ITEM_INDEX'], update, _context)    async def add_default_keyboard(self, update, _context):        return [            [                Button("Добавить задание➕", self.add_school_task,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, SchoolTaskAddition,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]class SchoolTaskAdditionDetailsMonth(BaseScreen):    description = '<strong>На какой месяц будет дано задание%s</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        for month in range(12):            real_month = month + 1            if real_month >= datetime.now().month:                keyboard.append([Button(MONTHS_DICT[real_month], self.get_month,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ADDING_TASK_TASK_MONTH': int(real_month)}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAdditionDetails,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_month(self, update, _context):        await get_payload_safe(self, update, _context, 'get_month_add_task', 'ADDING_TASK_TASK_MONTH')        return await SchoolTaskAdditionDetailsDay().move(update, _context)class SchoolTaskMonthChange(BaseScreen):    description = '<strong>На какой месяц будет дано задание%s</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        for month in range(12):            real_month = month + 1            if real_month >= datetime.now().month:                keyboard.append([Button(MONTHS_DICT[real_month], self.get_month,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ADDING_TASK_TASK_MONTH': int(real_month)}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAdditionDetails,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_month(self, update, _context):        await get_payload_safe(self, update, _context, 'get_month_add_task', 'ADDING_TASK_TASK_MONTH')        check_task = await check_task_status(_context)        if not check_task:            return await show_notification_screen(update, _context, 'send',                                                  "<strong>Я не могу выполнить Ваш запрос - пожалуйста, повторите "                                                  "попытку</strong>",                                                  [                                                      [Button("🔄Повторить попытку", SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK, SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        else:            cursor.execute(                'UPDATE ' + _context.user_data[                    'CURRENT_CLASS_NAME'] + '_Tasks SET task_month = %s WHERE item_index = %s',                (_context.user_data['ADDING_TASK_TASK_MONTH'], _context.user_data['ADDING_TASK_INDEX'],))            connection.commit()            cursor.execute(                'SELECT item_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',                (_context.user_data['ADDING_TASK_INDEX'],))            item_name = cursor.fetchall()            item_name = get_clean_var(item_name, 'to_string', 0, True)            cursor.execute(                'SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',                (item_name,))            _context.user_data['ADDING_TASK_INDEX'] = cursor.fetchall()            _context.user_data['ADDING_TASK_INDEX'] = get_clean_var(_context.user_data['ADDING_TASK_INDEX'],                                                                    'to_string', 0, True)            return await send_update_notification(update, _context, 'change', _context.user_data['ADDING_TASK_INDEX'],                                                  True)class SchoolTaskAdditionDetailsDay(BaseScreen):    description = '<strong>На какой день дано задание%s</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        for day in range(                int(monthrange(int(strftime("%Y", gmtime())), int(_context.user_data["ADDING_TASK_TASK_MONTH"]))[1])):            real_day = day + 1            if int(_context.user_data["ADDING_TASK_TASK_MONTH"]) == datetime.now().month:                if real_day > datetime.now().day:                    keyboard.append([Button(str(real_day), self.get_day,                                            source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                            payload=dumps({'ADDING_TASK_TASK_DAY': real_day}))])            else:                keyboard.append([Button(str(real_day), self.get_day,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ADDING_TASK_TASK_DAY': real_day}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAdditionDetailsMonth,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_day(self, update, _context):        await get_payload_safe(self, update, _context, 'get_day_add_task', 'ADDING_TASK_TASK_DAY')        _context.user_data["IS_IN_MEDIA_SCREEN"] = True        _context.user_data['ADDING_TASK_TASK_YEAR'] = datetime.now().year        return await MediaCapture().move(update, _context)class SchoolTaskChangeDay(BaseScreen):    description = '<strong>На какой день дано задание%s</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        for day in range(                int(monthrange(int(strftime("%Y", gmtime())), int(_context.user_data["ADDING_TASK_TASK_MONTH"]))[1])):            real_day = day + 1            if int(_context.user_data["ADDING_TASK_TASK_MONTH"]) == datetime.now().month:                if real_day > datetime.now().day:                    keyboard.append([Button(str(real_day), self.get_day,                                            source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                            payload=dumps({'ADDING_TASK_TASK_DAY': real_day}))])            else:                keyboard.append([Button(str(real_day), self.get_day,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'ADDING_TASK_TASK_DAY': real_day}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAdditionDetailsMonth,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_day(self, update, _context):        await get_payload_safe(self, update, _context, 'get_day_add_task', 'ADDING_TASK_TASK_DAY')        cursor.execute(            'UPDATE ' + _context.user_data[                'CURRENT_CLASS_NAME'] + '_Tasks SET task_day = %s WHERE item_index = %s',            (_context.user_data['ADDING_TASK_TASK_DAY'], _context.user_data['ADDING_TASK_INDEX'],))        connection.commit()        cursor.execute(            'SELECT item_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',            (_context.user_data['ADDING_TASK_INDEX'],))        item_name = cursor.fetchall()        item_name = get_clean_var(item_name, 'to_string', 0, True)        cursor.execute(            'SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',            (item_name,))        _context.user_data['ADDING_TASK_INDEX'] = cursor.fetchall()        _context.user_data['ADDING_TASK_INDEX'] = get_clean_var(_context.user_data['ADDING_TASK_INDEX'],                                                                'to_string', 0, True)        return await send_update_notification(update, _context, 'change',                                              _context.user_data['ADDING_TASK_INDEX'],                                              True)class SchoolTaskRemoval(BaseScreen):    async def add_default_keyboard(self, update, _context):        cursor.execute('SELECT * FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks')        db_check = cursor.fetchall()        try:            db_check = get_clean_var(db_check, "to_string", False, True)        except IndexError:            db_check = ""        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        keyboard = []        for task_index in range(db_length):            with suppress(KeyError):                button_name = await get_button_title(task_index, _context)                button_list = [                    Button(                        str(button_name), self.remove_task,                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                        payload=dumps({'task_index': task_index,                                       'db_check': db_check}),                    )                ]                keyboard.append(button_list)        exit_button = [Button(BUTTON_BACK, SchoolTaskManagementMain,                              source_type=SourceTypes.MOVE_SOURCE_TYPE)]        keyboard.append(exit_button)        return keyboard    async def get_description(self, update, _context):        await SchoolTasks().check_tasks(update, _context, None)        database_length = await get_var_from_database(None, "database_length_SchoolTasker", True, _context)        if database_length >= 1:            return "<strong>Какое из этих заданий Вы хотите удалить%s</strong>"        else:            return "<strong>На данный момент список заданий пуст!</strong>"    @register_button_handler    async def remove_task(self, update, _context):        await get_payload_safe(self, update, _context, 'delete_task', 'task_index')        await get_payload_safe(self, update, _context, 'delete_task', 'db_check')        return await SchoolTaskRemovalConfirmation().move(update, _context)class SchoolTaskRemovalConfirmation(BaseScreen):    description = "<strong>Вы действительно хотите удалить данное задание%s</strong>"    deletion_index = 0    async def add_default_keyboard(self, update, _context):        return [            [                Button("Удалить🗑️", self.delete_school_task, source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ],            [                Button(BUTTON_BACK, SchoolTaskRemoval, source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]    @register_button_handler    async def delete_school_task(self, update, _context):        check_task = await check_task_status(_context)        if not check_task:            return await show_notification_screen(update, _context, 'render',                                                  "<strong>Я не могу выполнить Ваш запрос - пожалуйста, повторите "                                                  "попытку</strong>",                                                  [                                                      [Button("🔄Повторить попытку", SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK, SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        else:            Global.index_store -= 1            task_index = _context.user_data['task_index']            user = update.effective_user            formatted_index = await get_var_from_database(task_index, "item_index", True, _context)            name = get_username(user.first_name, user.last_name, user.username)            await logger_alert([name, user.id], "delete", formatted_index, False, _context)            cursor.execute(                '''DELETE FROM ''' + _context.user_data['CURRENT_CLASS_NAME'] + '''_Tasks WHERE item_index = %s''',                (formatted_index,))            connection.commit()            if exists(str(settings.MEDIA_ROOT) + '/' + formatted_index + '/'):                rmtree(str(settings.MEDIA_ROOT) + '/' + formatted_index)            database_length = await get_var_from_database(None, "database_length_SchoolTasker", True, _context)            if database_length > 0:                keyboard = [                    [                        Button('⬅️ В меню редактора', SchoolTaskManagementMain,                               source_type=SourceTypes.MOVE_SOURCE_TYPE),                    ],                    [                        Button('⬅️ Удалить  ещё задание', SchoolTaskRemoval,                               source_type=SourceTypes.MOVE_SOURCE_TYPE),                    ],                    [                        Button('⬅️ На главный экран', MainMenu,                               source_type=SourceTypes.MOVE_SOURCE_TYPE)                    ],                ]            else:                keyboard = [                    [                        Button('⬅️ В меню редактора', SchoolTaskManagementMain,                               source_type=SourceTypes.MOVE_SOURCE_TYPE),                    ],                    [                        Button('⬅️ На главный экран', MainMenu,                               source_type=SourceTypes.MOVE_SOURCE_TYPE)                    ],                ]            return await show_notification_screen(update, _context, 'render',                                                  "✅<strong>Задание успешно удалено!</strong>", keyboard)    async def get_description(self, update, _context):        return "<strong>Вы действительно хотите удалить данное задание%s</strong>"class SchoolTaskChangeBase(BaseScreen):    description = "<strong>Что Вы хотите изменить в данном задании%s</strong>"    async def add_default_keyboard(self, update, _context):        check_index = _context.user_data["task_index"]        check_item = await get_var_from_database(check_index, "item_name", True, _context)        keyboard = [            [                Button("Предмет", self.change_school_item,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE,                       payload=dumps({"task_index": _context.user_data['task_index']}))            ],            [                Button("Задание", self.change_school_task,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE,                       payload=dumps({"deletion_index": _context.user_data['task_index']}))            ],            [                Button("День", self.change_task_day,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE,                       payload=dumps({"deletion_index": _context.user_data['task_index']}))            ],            [                Button("Месяц", self.change_task_month,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE,                       payload=dumps({"deletion_index": _context.user_data['task_index']}))            ],            [                Button(BUTTON_BACK, SchoolTaskChangeMain,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ]        ]        cursor.execute('SELECT groups FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',                       (check_item,))        groups = cursor.fetchall()        groups = get_clean_var(groups, 'to_int', 0, True)        if groups > 1:            keyboard.insert(2, [                Button("Группу", SchoolTaskChangeGroupNumber,                       source_type=SourceTypes.MOVE_SOURCE_TYPE)            ])        return keyboard    @register_button_handler    async def change_task_month(self, update, _context):        return await SchoolTaskMonthChange().move(update, _context)    @register_button_handler    async def change_task_day(self, update, _context):        return await SchoolTaskChangeDay().move(update, _context)    @register_button_handler    async def change_school_task(self, update, _context):        return await SchoolTaskChangeTask().move(update, _context)    @register_button_handler    async def change_school_item(self, update, _context):        await get_payload_safe(self, update, _context, 'change_task_item', 'task_index')        return await SchoolTaskChangeItem().move(update, _context)class SchoolTaskChangeMain(BaseScreen):    async def add_default_keyboard(self, update, _context):        cursor.execute('SELECT * FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks')        db_check = cursor.fetchall()        try:            db_check = get_clean_var(db_check, "to_string", False, True)        except IndexError:            db_check = ""        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        keyboard = []        for task_index in range(db_length):            with suppress(KeyError):                cursor.execute('SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks')                item_index = cursor.fetchall()                item_index = get_clean_var(item_index, 'to_string', task_index, True)                button_name = await get_button_title(task_index, _context)                button_list = [                    Button(                        str(button_name), self.change_task,                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                        payload=dumps({'task_index': task_index,                                       'db_check': db_check,                                       'ADDING_TASK_INDEX': item_index}),                    )                ]                keyboard.append(button_list)        exit_button = [Button(BUTTON_BACK, SchoolTaskManagementMain,                              source_type=SourceTypes.MOVE_SOURCE_TYPE)]        keyboard.append(exit_button)        return keyboard    async def get_description(self, update, _context):        await SchoolTasks().check_tasks(update, _context, None)        database_length = await get_var_from_database(None, "database_length_SchoolTasker", True, _context)        if database_length > 0:            return "<strong>Какое из этих заданий Вы хотите изменить%s</strong>"        if database_length < 1:            return "<strong>На данный момент список заданий пуст!</strong>"    @register_button_handler    async def change_task(self, update, _context):        await get_payload_safe(self, update, _context, 'change_task', 'task_index')        await get_payload_safe(self, update, _context, 'change_task', 'db_check')        await get_payload_safe(self, update, _context, 'change_task', 'ADDING_TASK_INDEX')        return await SchoolTaskChangeBase().move(update, _context)class SchoolTaskChangeItem(BaseScreen):    async def get_description(self, update, _context):        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            return '<strong>По какому предмету будет задание%s</strong>'        else:            return '<strong>В сообществе пока нету предметов!</strong>'    async def add_default_keyboard(self, update, _context):        keyboard = []        cursor.execute('SELECT COUNT(*) FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')        db_length = cursor.fetchall()        db_length = get_clean_var(db_length, 'to_int', 0, True)        if db_length > 0:            cursor.execute('SELECT main_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            main_name_list = cursor.fetchall()            cursor.execute('SELECT emoji FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items')            emoji_list = cursor.fetchall()            for i in range(db_length):                main_name = get_clean_var(main_name_list, 'to_string', i - 1, True)                emoji = get_clean_var(emoji_list, 'to_string', i - 1, True)                keyboard.append([Button(emoji + main_name, self.change_item,                                        source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                        payload=dumps({'task_item': main_name}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskManagementMain,                                source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def change_item(self, update, _context):        check_task = await check_task_status(_context)        if not check_task:            return await show_notification_screen(update, _context, 'render',                                                  "<strong>Я не могу выполнить Ваш запрос - пожалуйста, повторите "                                                  "попытку</strong>",                                                  [                                                      [Button("🔄Повторить попытку", SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ],                                                      [Button(BUTTON_BACK, SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)                                                       ]])        else:            await get_payload_safe(self, update, _context, 'change_task_item', 'task_item')            cursor.execute(                "UPDATE " + _context.user_data[                    'CURRENT_CLASS_NAME'] + "_Tasks set item_name = %s WHERE item_index = %s",                (_context.user_data['task_item'], _context.user_data["task_index"],))            connection.commit()            await send_update_notification(update, _context, "change", _context.user_data["task_index"], False)            return await show_notification_screen(update, _context, 'render',                                                  "✅<strong>Задание успешно изменено!</strong>", [                                                      [Button('⬅️ В меню редактора', SchoolTaskManagementMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                      [Button("⬅ Изменить ещё задания", SchoolTaskChangeMain,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)],                                                      [Button('⬅️ На главный экран', MainMenu,                                                              source_type=SourceTypes.MOVE_SOURCE_TYPE)]])class SchoolTaskChangeTask(BaseScreen):    description = "<strong>Введите новый текст задания:</strong>"    current_index = int()    task_description = str()    async def add_default_keyboard(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = 'CHANGING_TASK_DESCRIPTION'        await get_payload_safe(self, update, _context, 'change_task_description', 'deletion_index')        return [            [                Button(BUTTON_BACK, self.go_back,                       source_type=SourceTypes.HANDLER_SOURCE_TYPE)            ]        ]    @register_button_handler    async def go_back(self, update, _context):        _context.user_data['CURRENT_TYPING_ACTION'] = ''        return await SchoolTaskChangeBase().move(update, _context)class SchoolTaskChangeGroupNumber(BaseScreen):    description = "<strong>Какой группе дано задание%s</strong>"    async def add_default_keyboard(self, update, _context):        keyboard = []        for i in range(int(_context.user_data['ADDING_TASK_GROUPS'])):            keyboard.append([Button('Группа ' + str(i + 1), self.get_group_number,                                    source_type=SourceTypes.HANDLER_SOURCE_TYPE,                                    payload=dumps({'ADDING_TASK_GROUP_NUMBER': str(i + 1)}))])        keyboard.append([Button(BUTTON_BACK, SchoolTaskAddition, source_type=SourceTypes.MOVE_SOURCE_TYPE)])        return keyboard    @register_button_handler    async def get_group_number(self, update, _context):        await get_payload_safe(self, update, _context, 'add_task_group_number', 'ADDING_TASK_GROUP_NUMBER')        cursor.execute(            'UPDATE ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks SET group_number = %s WHERE item_index = %s',            (_context.user_data['ADDING_TASK_GROUP_NUMBER'], _context.user_data['ADDING_TASK_INDEX'],))        connection.commit()        cursor.execute(            'SELECT item_name FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Tasks WHERE item_index = %s',            (_context.user_data['ADDING_TASK_INDEX'],))        item_name = cursor.fetchall()        item_name = get_clean_var(item_name, 'to_string', 0, True)        cursor.execute(            'SELECT item_index FROM ' + _context.user_data['CURRENT_CLASS_NAME'] + '_Items WHERE main_name = %s',            (item_name,))        _context.user_data['ADDING_TASK_INDEX'] = cursor.fetchall()        _context.user_data['ADDING_TASK_INDEX'] = get_clean_var(_context.user_data['ADDING_TASK_INDEX'],                                                                'to_string', 0, True)        return await send_update_notification(update, _context, 'change', _context.user_data['ADDING_TASK_INDEX'],                                              True)    @register_button_handler    async def return_back(self, update, _context):        return await SchoolTaskChangeBase().move(update, _context)